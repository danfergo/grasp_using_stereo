#!/usr/bin/env python
# author- Achu
# email- achuwilson@gmail.com
'''
TODO
Gelsight pad works only in one orientation, Need to add orientation transformations

'''

# import rospy
import math
import sys

# from sensor_msgs.msg import PointCloud2
# import std_msgs.msg
# import sensor_msgs.point_cloud2 as pcl2

import pybullet as p
import time
import numpy as np

import pybullet_data

mode = 0

# # initialize ROS Node
# rospy.init_node('gelsight_pub_example')
# # the pointclould generated by Gelsight will be published as a PointCloud2 message with name "/gelsight_pcl"
# pcl_pub = rospy.Publisher("/gelsight_pcl", PointCloud2)
# # give time to roscore to make the connections
# rospy.sleep(1.)

# initialize pybullet
cid = p.connect(p.SHARED_MEMORY)
if (cid < 0):
    p.connect(p.GUI)
# add the default search directories of pyBullet. THis is where themodels of Kuka iiwa and wsg gripper is located
p.setAdditionalSearchPath(pybullet_data.getDataPath())
p.resetSimulation()

###############load test objects
# create coin ( mass is set to 0 in order to hold its position in space)
coinMass = 0
# coin = p.createCollisionShape(p.GEOM_MESH, fileName="data/coin.obj", meshScale=[0.001, 0.001, 0.001],
#                               flags=p.GEOM_FORCE_CONCAVE_TRIMESH)
# coinUid = p.createMultiBody(coinMass, coin, -1, [0.7, 0, 0.645], [0, 0.70711, 0.0, 0.70711])
# create ball
sphereRadius = 0.01
mass = 0.0
colSphereId = p.createCollisionShape(p.GEOM_SPHERE, radius=sphereRadius)
ballId = p.createMultiBody(mass, colSphereId, -1, (0.7, 0.05, 0.645))

# load the robot, environment etc
objects = [p.loadURDF("plane.urdf", 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000)]
objects = [
    p.loadURDF("kuka_iiwa/model_vr_limits.urdf", 0.00000, -0.0000, 0.600000, 0.000000, 0.000000, 0.000000, 1.000000)]
kuka = objects[0]
jointPositions = [-0.5000000, -0.000000, 0.000000, 1.570793, 0.000000, -1.036725, 0.000001]
for jointIndex in range(p.getNumJoints(kuka)):
    p.resetJointState(kuka, jointIndex, jointPositions[jointIndex])
    p.setJointMotorControl2(kuka, jointIndex, p.POSITION_CONTROL, jointPositions[jointIndex], 0)

objects = p.loadSDF("gripper/wsg50_one_motor_gripper_new_free_base.sdf")
kuka_gripper = objects[0]
print("kuka gripper=")
print(kuka_gripper)

p.resetBasePositionAndOrientation(kuka_gripper, [0.923103, -0.200000, 1.250036],
                                  [-0.000000, 0.964531, -0.000002, -0.263970])
jointPositions = [0.000000, -0.011130, -0.206421, 0.205143, -0.009999, 0.000000, -0.010055, 0.000000]
for jointIndex in range(p.getNumJoints(kuka_gripper)):
    p.resetJointState(kuka_gripper, jointIndex, jointPositions[jointIndex])
    p.setJointMotorControl2(kuka_gripper, jointIndex, p.POSITION_CONTROL, jointPositions[jointIndex], 0)

print("num joints gripper", p.getNumJoints(kuka_gripper))

kuka_cid = p.createConstraint(kuka, 6, kuka_gripper, 0, p.JOINT_FIXED, [0, 0, 0], [0, 0, 0.025], [0, 0, 0])

# objects = [p.loadURDF("table/table.urdf", 1.000000,-0.200000,0.000000,0.000000,0.000000,0.707107,0.707107)]
objects = [p.loadURDF("table/table.urdf", 0.36000000, -0.00000, 0.000000, 0.000000, 0.000000, 0.707107, 0.707107)]

p.setGravity(0.000000, 0.000000, 0.000000)
p.setGravity(0, 0, -10)

p.setRealTimeSimulation(1)
ref_time = time.time()
print("num joints kuka", p.getNumJoints(kuka))
print("num joints gripper", p.getNumJoints(kuka_gripper))

jointPositions = [-0.5000000, -0.000000, 0.000000, 1.570793, 0.000000, -1.036725, 0.000001]

##########create the gelsight gripper pad
gWidth = 0.024
gHeight = 0.024
gThickness = 0.001
gMass = 0.1
numHPixel = 256
numVPixel = 256

p.MAX_RAY_INTERSECTION_BATCH_SIZE = 300

colBoxId2 = p.createCollisionShape(p.GEOM_BOX, halfExtents=[gWidth, gThickness, gHeight])
gelUid = p.createMultiBody(gMass, colBoxId2, -1, [0.3, 0, 0.7])
print(p.getBodyInfo(gelUid))
gel_cid = p.createConstraint(kuka_gripper, 5, gelUid, -1, p.JOINT_FIXED, [0, 0, 0], [0.0, 0.009, 0.1], [0, 0, 0])
###############################

# slider control for the gripper
gripper = p.addUserDebugParameter("gripper", -0.05, 0.02, -0.040)

kukaEndEffectorIndex = 6
numJoints = 7
jd = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]


# This is the function that emulates the behavious of Gelsight
# The rayTest functionality of Bullet, which returns the intersection/collision
# distance of a directed ray is used.
# each pixel of the gelsight shoots a ray perpendicular to it and the distance
# at which something comes in its path is reported, which is then packed together
# and published as a pointcloud message
def getRay():
    #
    # TODO consider and compensate the orientation also.
    #	  else gelsight can return reliable data in only one orientation
    gelDepth = 0.05
    gelPos, gelOrn = p.getBasePositionAndOrientation(gelUid)
    startRayPosCorner = np.array(gelPos) - np.array([0.0, gHeight / 2.0, -gWidth / 2.0])
    startRayPosHor = np.array(gelPos) - np.array([0.0, -gHeight / 2.0, -gWidth / 2.0])
    startRayPosVer = np.array(gelPos) - np.array([0.0, gHeight / 2.0, gWidth / 2.0])
    hPixels = np.linspace(startRayPosCorner[1], startRayPosHor[1], numHPixel)
    vPixels = np.linspace(startRayPosCorner[2], startRayPosVer[2], numVPixel)
    # print("hpixel, vpixel",len(hPixels),len(vPixels))
    rayFromPos = []
    rayToPos = []
    data = []
    startDepth = gelPos[0]
    endDepth = gelPos[0] + gelDepth
    hcnt = 0
    vcnt = 0

    for i in hPixels:
        hcnt = hcnt + 0.02
        vcnt = 0
        # print hcnt
        for j in vPixels:
            vcnt = vcnt + 0.02
            rayData = p.rayTest([startDepth, i, j], [endDepth, i, j])
            if ((rayData[0][0] > -1) and (rayData[0][0] < 1) and (mode == 0)):
                data.append([vcnt, hcnt, 10 + (-1 * (+rayData[0][2]) / gelDepth)])
            elif ((rayData[0][0] > -1) and (rayData[0][0] < 3) and (mode == 1)):
                data.append([vcnt, hcnt, 10 + (-1 * (+rayData[0][2]) / gelDepth)])

    header = std_msgs.msg.Header()
    header.stamp = rospy.Time.now()
    header.frame_id = 'map'
    # create pcl from points
    scaled_polygon_pcl = pcl2.create_cloud_xyz32(header, data)
    # publish the message
    pcl_pub.publish(scaled_polygon_pcl)


# Function to move the Kuka Robot to xyz position
def movePos(xp, yp, zp):
    numSteps = 1000
    pos = [xp, yp, zp]
    orn = p.getQuaternionFromEuler([3.14, 0, 0])
    jointPoses = p.calculateInverseKinematics(kuka, kukaEndEffectorIndex, pos, orn, jointDamping=jd)
    for steps in range(numSteps):
        p.setGravity(0, 0, -10)
        for i in range(numJoints):
            p.setJointMotorControl2(bodyIndex=kuka, jointIndex=i, controlMode=p.POSITION_CONTROL,
                                    targetPosition=jointPoses[i], targetVelocity=0, force=500, positionGain=0.03,
                                    velocityGain=1)


while True:

    kbd = p.getKeyboardEvents()
    if len(kbd) > 0:
        try:
            key1 = chr(kbd.items()[0][0])
            val1 = kbd.items()[0][1]
        except:
            key1 = kbd.items()[0][0]
            val1 = kbd.items()[0][1]
        if ((key1 == '1') and (val1 == 4)):  # press  and release 1 continuously till it reaches waypoint1
            movePos(0.35, 0.2, 1.2)
        elif ((key1 == '2') and (val1 == 4)):  # press  and release 2 continuously till it reaches waypoint2
            movePos(0.7, 0, 1)
        elif ((key1 == '3') and (val1 == 4)):  # press  and release 3 continuously till it reaches waypoint3 - Coin
            mode = 0
            movePos(0.7, 0, 0.94)
        elif ((key1 == '4') and (val1 == 4)):  # press  and release 4 continuously till it reaches waypoint14 - Ball
            mode = 1
            movePos(0.7, 0.05, 0.94)
    p.setGravity(0, 0, -10)
    p.stepSimulation()

    grip_pos = float(p.readUserDebugParameter(gripper))
    p.setJointMotorControl2(kuka_gripper, 4, p.POSITION_CONTROL, grip_pos, 1)
    p.setJointMotorControl2(kuka_gripper, 6, p.POSITION_CONTROL, grip_pos, 1)
    # we are simulating gelsight only when the gripper is about to close, since the simulation is computationally heavy
    if (grip_pos > -0.003):
        getRay()

p.disconnect()